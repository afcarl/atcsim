[Question P2.1]

Une méthode virtuelle pure (abstraite) n'est pas définie (implémentée) dans la
classe où elle est déclarée et doit donc obligatoirement être définie dans les
classes filles (héritants de la super-classe) (pas forcément les descendants
directs). Une méthode virtuelle possède une implémentation par défaut dont les
classes filles héritent. Elles peuvent cependant la redéfinir. Une classe
contenant une méthode virtuelle pure est dite abstraite et ne peut être instanciée.

Seul les méthodes virtuelles (non abstraites) doivent obligatoirement être
définies, dans notre cas il s'agit du constructeur et du destructeur par défaut.

[Question P3.1]

Il est nécessaire de définir les méthodes comme virtuelles dans la super-class,
afin que celles-ci puissent être redéfinies dans les classes filles.
Des références vers les objets (et non les objets eux-mêmes) doivent être stockées
dans le conteneur, afin que le RTTI (Run-Time Type Information) détermine le type
de l'objet à l'exécution et non à la compilation comme c'est habituellement le cas.

[Question P4.1]

Il suffit de projeter le vecteur de norme velocity et d'argument cape sur les axes x et y.
C'est-à-dire xVelocity = velocity * cos(cape) et yVelocity = velocity * sin(cape).
Attention au fait que std::cos() et std::sin() prennent des radians comme arguments.

[Question P5.1]

Le paramètre des fonctions Collides et onCollision est probablement une
référence sur la seconde entité avec laquelle nous testons la collision. Notre
implémentation n'utilise pas ces deux méthodes mais une méthode
checkForCollision qui prends effectivement une référence sur une entité comme
paramètre.

